## Строка
   - Это тип данных, который представляет собой последовательность символов типа `char`. В примере "Hello world!" строка представляет собой последовательность символов, начиная с буквы "H" и заканчивая восклицательным знаком "!". Все символы между ними включительно также входят в эту строку. Строки могут содержать буквы, цифры, символы пунктуации и другие символы.

   - Строки используются для представления и обработки текстовой информации в программировании. Это может включать в себя работу с текстовыми данными, ввод и вывод текста, обработку и анализ текста, а также многие другие задачи, связанные с текстом.

   - Длина строки определяется количеством символов, которые она содержит. Длину строки можно получить с помощью специальных функций или методов, предоставляемых языками программирования. Важно отметить, что длина значения строковой переменной может изменяться во время выполнения программы, например, при добавлении или удалении символов из строки.

Эти пункты помогают понять основные концепции, связанные с строками в программировании, и объясняют их важность при работе с текстовыми данными в программах.

![[Pasted image 20231208095759.png]]
### String
- Используется по умолчанию;
- После создания объекта "строка" его значение в памяти не изменяется.
### StringBuilder
- После создания объекта "строка" его значение в памяти может изменяться;
- не потокобезопасный;
- более эффективный, чем StringBuffer.
### StringBuffer
- После создания объекта "строка" его значение в памяти может изменяться;
- потокобезопасный;
- менее эффективные чем StringBuilder.
## Класс String: основные характеристики
- Класс String в Java предназначен для работы со строками;
- Все строковые литералы, определенные в Java-программе (например, "abcd") — это объекты класса String;
- String входит в пакет java.lang, поэтому его не нужно импортировать;
- После создания объекта String его значение не может быть изменено, так как любое изменение приводит к созданию нового объекта. Это делает класс потокобезопасным, но затратным по памяти.
### Объект-строка String создается 
- с помощью операции `new`, либо 
- прямой инициализацией.
### Создание строки String:
```java
String s1 = new String("Ижевск");  //операция new
String s2 = "Воткинск";            //прямая инициализация
System.out.println(s1 + " " + s2);
```
![[Pasted image 20231208132820.png]]
## Строковые ссылки и объекты класса String
- При создании объекта-строки объектная ссылка, как обычно, размещается в стеке, а сам объект — в динамической памяти (Heap), точнее в её специальной части, выделенной для строк-объектов, которая называется "пул строк" (String pool).
- В пуле строк хранятся все строковые литералы, созданные в программе.
- В случае совпадения литералов они в пуле строк не дублируются, а используются один и тот же объект.

```java
String s1 = "Cat";
String s2 = "Cat";
String s3 = new String("Cat");
s1 == s2;  // true
s1 == s3;  // false
```
### Сравнение строк на равенство
- Для сравнения строк на равенство значений необходимо использовать метод `equals():`
```java
s1.equals(s2); //true, если строки s1 и s2 равны
```
### Сравнение строк на "больше-меньше"
- Лексико-графический порядок (по алфавиту): посимвольное сравнение строк до первого не совпадающего символа. Та строка считается меньше, не совпадающий символ которой меньше.
```
"Петров" больше чем "Петричев", так как 'о' > 'и'
"Иванов" меньше, чем "Иванова", так как недостающий символ считают за нуль
```

- Для сравнения строк "по алфавиту" используют метод `compareTo()`, который возвращает значение :
  - 0, если строки равны,
  - положительное значение, если первая строка больше второй,
  - отрицательное значение, если первая строка меньше второй.
- Если нужно сравнить строки без учёта регистра символов, то используют `compareToIgnoreCase()`
### Пример сравнения строк:
```java
// Сравнение строк на равенство 
String s1 = new String("Ижевск");
String s2 = new String("Воткинск");
String s3 = new String("Ижевск");
System.out.printl(s1.equals(s2));     // false, т.к. "Ижевск" != "Воткинск"
System.out.printl(s1.equals(s3));     // true,  т.к. "Ижевск" == "Воткинск"

// Сравнение строк лексико-графическоге (по алфавиту)
System.out.printl(s1.compareTo(s2));  // 6,  т.к. "Ижевск" > "Воткинск"
System.out.printl(s1.compareTo(s2));  // 0,  т.к. "Ижевск" == "Воткинск"
System.out.printl(s1.compareTo(s2));  // -6, т.к. "Ижевск" < "Воткинск"
```
### Консоль:
```
false
true
6
0
-6
```

## Сцепление строк (конкатенация)
- Строки можно сцеплять друг с другом операцией `+` (конкатенация), а
также с помощью метода `concat()`.
![[Pasted image 20231208140304.png]]

- Сцеплять строки можно и с объектами других классов (переменными
других типов), при этом значения этих объектов (переменных) будут
автоматически приведены к строке. Это происходит благодаря неявному
вызову метода `toString()`:
![[Pasted image 20231209004521.png]]
### Пример сцепления строк:
 ```java
// Операция сложения (конкатенации) строк
String s1 = "to be";
String s2 = s1 + " or not " + s1;
System.out.println(s2);

// Сцепление с другими типами
int x = 2, y = 2;
String s3 = x + " * " + y + " = " + (x * y);
System.out.println(s3);
```

### Консоль:
```
to be or not to be
2 * 2 = 4
```

## Некоторые операции и методы строк String

| №  | Методы                     | Описание                                                         |
|----|----------------------------|------------------------------------------------------------------|
| 1  | charAt(int index)          | Возвращает символ по указанному индексу.                         |
| 2  | int compareTo(String anotherString) | Сравнивает две строки лексически.                                 |
| 3  | int compareToIgnoreCase(String str)  | Сравнивает две строки лексически, игнорируя регистр букв.        |
| 4  | String concat(String str)           | Объединяет указанную строку с другой строкой, путем добавления ее в конец (то же, что и '+').|
| 5  | String copyValueOf(char[] data)     | Возвращает строку, которая представляет собой последовательность символов, указанный массив.|
| 6  | boolean endsWith(String suffix)     | Проверяет заканчивается ли эта строка указанным окончанием.      |
| 7  | boolean equalsIgnoreCase(String anotherString) | Сравнивает данную строку с другой строкой, игнорируя регистр букв.|
| 8  | int hashCode()                      | Возвращает хэш-код для этой строки.                              |
| 9  | int indexOf(String str)             | Возвращает индекс первого вхождения указанной подстроки в данной строке.|
| 10 | int length()                        | Возвращает длину строки.                                         |
| 11 | boolean matches(String regex)      | Сообщает, соответствует ли эта строка заданному регулярному выражению.            |
| 12 | String replace(char oldChar, char newChar) | Возвращает новую строку, в результате, заменив все вхождения oldChar в этой строке на newChar. |
| 13 | String[] split(String regex)       | Разделение строки на массив строк. Регулярное выражение regex задает, где именно происходит разделение между строками.|
| 14 | boolean startsWith(String prefix)  | Проверяет, начинается ли эта строка с заданного префикса.                         |
| 15 | String substring(int beginIndex)   | Возвращает новую строку, которая является подстрокой данной строки.                |
| 16 | char[] toCharArray()               | Преобразует эту строку в новый массив символов.                                    |
| 17 | String toLowerCase()               | Преобразует все символы в данной строке в нижний регистр, используя правила данного языкового стандарта. |
| 18 | String toUpperCase()               | Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта. |
| 19 | String trim()                      | Возвращает копию строки с пропущенными начальными и конечными пробелами.           |
| 20 | static String valueOf(primitive data type x) | Возвращает строковое представление переданного типа данных аргумента.           |

### Задача
Дана текстовая строка. Проверить является ли она палиндромом?
Палиндром - это такая строк, которая читается одинаково справа налево и слева направо.
![[Pasted image 20231209005914.png]]
### Код программы:
```java
import java.util.Scanner;

public class RefString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите строку");
        String str = scanner.nextLine();                    // чтение с клавиатуры
        int len = str.length();                             // длина строки
        // Проверка на палиндром строкой str
        boolean isPalindrome = true;                        // Признак палиндрома
        for (int i = 0; i < len / 2; i++) {                 // до середины
            if (str.charAt(i) != str.charAt(len - i - 1)) { // если не совпали, то false
                isPalindrome = false;
                break;
            }
        }
        if (isPalindrome)
            System.out.println("Это палиндром");
        else
            System.out.println("Это не палиндром");

        scanner.close();
    }
}
```
### Консоль:
```
Введите строку
мадам
Это палиндром
```
### Консоль:
```
Введите строку
лопата
Это не палиндром 
```
### Пример удаления всех вхождений подстроки в строку:
```java
System.out.println("Введите строку");
String str = scanner.nextLine();

System.out.println("Введите удаляемую подстроку");
String str1 = scanner.nextLine();

str = str.replaceAll(str1, "");
System.out.println("Полученная строка = " + str);
```
### Консоль:
```
Введите строку
барабан
Введите удаляемую подстроку
ба
Полученная строка = ран
```
### Пример разбиения строки на слова:
```java
String str = new String("Ижевск столица Удмуртской Республики");
System.out.println("Строка " + str + " состоит из слов:");
String[] words = str.split(" ");  // разделитель – один пробел
for(String word : words)          // вывод слов массива word
System.out.println(word);
```
### Консоль:
```
Строка Ижевск столица Удмуртской Республики состоит из слов:
Ижевск
столица
Удмуртской
Республики
```

## Преобразование строки в число (или другой объект) и наоборот

• Для преобразования объекта класса или значения любого примитивного
типа данных в строковое представление можно использовать метод
`String.valueOf()`;

• Для перевода строкового представления в число можно использовать
методы соответствующих числовых классов-оболочек, которые
начинаются на parse, например `parseInt()`, `parseDouble()` и т. п.

### Примеры преобразований:
```java
// Преобразование примитивного типа в строку
String s1 = String.valueOf(111);      // Преобразование целого в строку
String s2 = String.valueOf(3.14D);    // Преобразование вещественного
String s3 = String.valueOf(123456L);  // Преобразование long
String s4 = String.valueOf(true);     // Преобразование логического
String s = s1 + " " + s2 + " " + s3 + " " + s4;
System.out.println(s);

// Преобразование строки в объект числового класса-оболочки
Integer i = Integer.parseInt("777");
Float f = Float.parseFloat("2.71F");
Double d = Double.parseDouble("1.23E-02");
System.out.println(i + " " + f + " " + d);
```
### Консоль:
```
111 3.14 123456 true
777 2.71 0.0123
```

## Класс StringBuilder
Объекты класса `String` являются неизменными, поэтому частая их модификация приводит к созданию новых объектов, что в свою очередь приводит к расходу памяти. Для решения этой проблемы были созданы классы `java.lang.StringBuffer` и `java.lang.StringBuilder`, которые позволяют более эффективно работать над модификацией строки.

Оба класса имеют сходные операции со `String`, объекты этих классов представляют собой последовательности символов, которые могут расширяться и модифицироваться.

Класс `StringBuffer` потокобезопасный, но менее эффективный по скорости чем `StringBuilder`.

## Понятие ёмкости(capacity)
Понятие ёмкости (capacity) в контексте классов `StringBuilder` и `StringBuffer` в Java относится к объему памяти, который резервируется для хранения символьных данных.
- **Начальная ёмкость**: По умолчанию, когда создается объект `StringBuilder` или `StringBuffer`, для него резервируется память, способная вместить 16 символов, не считая место для терминального нулевого символа, который обозначает конец строки.
- **Динамическое расширение**: Если при добавлении новых символов в строку текущая ёмкость оказывается недостаточной, классы автоматически увеличивают её размер. Это происходит за счет создания нового массива символов большего размера и копирования в него содержимого из старого массива.
- **Фактор расширения**: Размер новой ёмкости обычно рассчитывается как (старая ёмкость * 2) + 2, хотя это может варьироваться в зависимости от реализации JVM.
![[Pasted image 20231209012938.png]]
### Создание строки StringBuffer / StringBuilder
```java
// Создание пустой строки, capacity = 16
StringBuffer strB1 = new StringBuffer();

// Создание непустой строки, capacity = длина строки + 16 
StringBuffer strB2 = new StringBuffer("Глазов");

// Инициализация другой строки
StringBuffer strB3 = new StringBuffer(strB2);

// Явное указание capacity
StringBuffer strB4 = new StringBuffer(50);
```

### Пример создания и изменения объектов класса StringBuilder
```java
StringBuilder s = new StringBuilder(""); // Пустая строка

System.out.println("Строка = " + s + ", длина = " + s.length() + ", емкость = " + s.capacity());

s.append("Умпуруксой"); // Добавили строку "Умпуруксой"
System.out.println("Строка = " + s + ", длина = " + s.length() + ", емкость = " + s.capacity());

s.append(" университет"); // Добавили строку " университет"
System.out.println("Строка = " + s + ", длина = " + s.length() + ", емкость = " + s.capacity());
```

### Консоль:
```
Строка = , длина = 0, емкость = 16
Строка = Умпуруксой, длина = 10, емкость = 16
Строка = Умпуруксой университет, длина = 22, емкость = 34
```

## Некоторые методы обработки строк StringBuilder / StringBuffer

| №  | Методы                         | Описание                                             |
|----|--------------------------------|------------------------------------------------------|
| 1  | StringBuffer append(String str) | Присоединяет аргумент str к строке                    |
| 2  | StringBuffer delete(int start, int end) | Удаляет из строки символы от start до end            |
| 3  | int indexOf(String str)         | Возвращает индекс первого вхождения подстроки        |
| 4  | StringBuffer insert(int offset, String str) | Вставка в строку строки str в позицию offset          |
| 5  | int length()                    | Возвращает длину строки                              |
| 6  | StringBuffer reverse()          | Переворачивает строку                                |
| 7  | StringBuffer substring(int start, int end) | Возвращает подстроку от start до end                 |
| 8  | и другие                        |                                                      |

### Пример использования StringBuffer:
```java
StringBuffer s = new StringBuffer("Ижевск столица"); // Исходная строка s
System.out.println(s);

s.append(" Удмуртии");                               // Добавили к строке "Удмуртии"
System.out.println(s);

s.delete(s.indexOf("Ижевск"), "Ижевск".length());    // Удалили слово "Ижевск"
System.out.println(s);
 
s.insert(0, "Главой ");                              // Вставили слово "Главой" в начало
System.out.println(s);  

s.insert(s.indexOf("столица"), "республики ");       // Вставили "республики" перед "столица"
System.out.println(s);
```

### Консоль:
```
Ижевск столица
Ижевск столица Удмуртии
столица Удмуртии
Главой столица Удмуртии
Главой республики столица Удмуртии
```

### Задача:
Дана строка символов. Проверить, соблюден ли баланс круглых скобок в строке.
### Код программы:
```java
public static void main(String[] args) {
    StringBuilder s = new StringBuilder("(a + (1 + 2) * (3 - 4))/(a - b)");

    int count = 0; // счетчик открывающих скобок
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(')
            count++;
        if (s.charAt(i) == ')')
            count--;
        if (count < 0)
            break;
    }
    System.out.println("Баланс скобок в строке " + s
        + (count == 0 ? " соблюден" : " нарушен"));
}
```

### Консоль:
```
Баланс скобок в строке (a + (1 + 2) * (3 - 4))/(a - b) соблюден
// другая строка:
Баланс скобок в строке (a + (1 + 2) * (3 - 4) /(a - b) нарушен
```