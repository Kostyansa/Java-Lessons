## String
Это тип данных, который представляет собой последовательность символов типа `char`. Например строка "Hello world!" представляет собой последовательность символов, начиная с буквы "H" и заканчивая восклицательным знаком "!". Все символы между ними включительно также входят в эту строку. Строки могут содержать буквы, цифры, пунктуацию и другие символы.
Строки используются для представления и обработки текстовой информации в программировании: для работы с текстовыми данными, ввод и вывод текста, обработку и анализ текста, а также многие другие задачи, связанные с текстом.
Длина строки определяется количеством символов, которые она содержит. Длину строки можно получить с помощью специальных функций или методов, предоставляемых языками программирования (в java это функция `.length()`). Важно отметить, что длина значения строковой переменной может изменяться во время выполнения программы, например, при добавлении или удалении символов из строки.
## Строковые типы в Java
![[Pasted image 20231208095759.png]]
**String**
- Используется по умолчанию;
- После создания объекта этого класса его значение в памяти не изменяется, изменить можно только создав новый объект.
**[[StringBuilder]]**
- После создания объекта этого класса его значение в памяти может изменяться;
- не потокобезопасный (об этом позже);
- более эффективный, чем StringBuffer.
**StringBuffer**
- После создания объекта "строка" его значение в памяти может изменяться;
- потокобезопасный (об этом позже);;
- менее эффективный чем StringBuilder.
## Класс String
Класс String в Java предназначен для работы со строками. Все строковые литералы, определенные в Java-программе (например, "abcd") — это объекты класса String. String входит в пакет java.lang, поэтому его не нужно импортировать. После создания объекта String его значение не может быть изменено, так как любое изменение приводит к созданию нового объекта. Это делает строки безопасными, но затратным по памяти.

Объект-строка String создается:
- с помощью операции `new`, либо 
- прямой инициализацией.

```java
String s1 = new String("Ижевск");  //операция new
String s2 = "Воткинск";            //прямая инициализация
System.out.println(s1 + " " + s2);
```
![[Pasted image 20231208132820.png]]
## Строковые ссылки и объекты класса String
При создании объекта-строки объектная ссылка, как обычно, размещается в стеке, а сам объект — в динамической памяти (Heap/куче), точнее в её специальной части, выделенной для строк-объектов, которая называется "пул строк" (String pool). В пуле строк хранятся все строковые литералы, созданные в программе. В случае совпадения литералов они в пуле строк не дублируются, а используются один и тот же объект.

```java
String s1 = "Cat";
String s2 = "Cat";
String s3 = new String("Cat");
s1 == s2;  // true
s1 == s3;  // false
```
### Сравнение строк на равенство
Для сравнения строк на равенство значений необходимо использовать метод `equals():`
```java
s1.equals(s2); //true, если строки s1 и s2 равны
```
### Сравнение строк на "больше-меньше"
Строки сравниваются в, так называемом лексико-графический порядоке или по алфавиту. Лексико-графический порядок (по алфавиту): посимвольное сравнение строк до первого не совпадающего символа. Та строка считается меньше, не совпадающий символ которой меньше.
```
"Петров" больше чем "Петричев", так как 'о' > 'и'
"Иванов" меньше, чем "Иванова", так как недостающий символ считают за нуль
```

Для сравнения строк "по алфавиту" используют метод `compareTo()`, который возвращает значение :
  - 0, если строки равны,
  - положительное значение, если первая строка больше второй,
  - отрицательное значение, если первая строка меньше второй.
Если нужно сравнить строки без учёта регистра символов, то используют `compareToIgnoreCase()`
Пример сравнения строк:
```java
// Сравнение строк на равенство 
String s1 = new String("Ижевск");
String s2 = new String("Воткинск");
String s3 = new String("Ижевск");
System.out.printl(s1.equals(s2));     // false, т.к. "Ижевск" != "Воткинск"
System.out.printl(s1.equals(s3));     // true,  т.к. "Ижевск" == "Ижевск"

// Сравнение строк лексико-графическоге (по алфавиту)
System.out.printl(s1.compareTo(s2));  // 6,  т.к. "Ижевск" > "Воткинск"
System.out.printl(s1.compareTo(s2));  // 0,  т.к. "Ижевск" == "Ижевск"
System.out.printl(s1.compareTo(s2));  // -6, т.к. "Ижевск" < "Воткинск"
```
Консоль:
```
false
true
6
0
-6
```

## Сложение строк (конкатенация)
Строки можно сцеплять друг с другом операцией `+` (конкатенация), а также с помощью метода `concat()`.
![[Pasted image 20231208140304.png]]

Сцеплять строки можно и с объектами других классов (переменными других типов), при этом значения этих объектов (переменных) будут автоматически приведены к строке. Это происходит благодаря неявному вызову метода `toString()`:
![[Pasted image 20231209004521.png]]
Пример сложения строк:
 ```java
// Операция сложения (конкатенации) строк
String s1 = "to be";
String s2 = s1 + " or not " + s1;
System.out.println(s2);

// Сцепление с другими типами
int x = 2, y = 2;
String s3 = x + " * " + y + " = " + (x * y);
System.out.println(s3);

// Тоже самое что и:
String s4 = Integer.toString(x) + " * " + Integer.toString(y) + " = " + Integer.toString(x * y);
System.out.println(s4);
```
Консоль:
```
to be or not to be
2 * 2 = 4
```

## Некоторые полезные методы класса String
| №  | Методы                     | Описание                                                         |
|----|----------------------------|------------------------------------------------------------------|
| 1  | charAt(int index)          | Возвращает символ по указанному индексу.                         |
| 2  | int compareTo(String anotherString) | Сравнивает две строки лексически.                                 |
| 3  | int compareToIgnoreCase(String str)  | Сравнивает две строки лексически, игнорируя регистр букв.        |
| 4  | String concat(String str)           | Объединяет указанную строку с другой строкой, путем добавления ее в конец (то же, что и '+').|
| 5  | String copyValueOf(char[] data)     | Возвращает строку, которая представляет собой последовательность символов, указанный массив.|
| 6  | boolean endsWith(String suffix)     | Проверяет заканчивается ли эта строка указанным окончанием.      |
| 7  | boolean equalsIgnoreCase(String anotherString) | Сравнивает данную строку с другой строкой, игнорируя регистр букв.|
| 8  | int hashCode()                      | Возвращает хэш-код для этой строки.                              |
| 9  | int indexOf(String str)             | Возвращает индекс первого вхождения указанной подстроки в данной строке.|
| 10 | int length()                        | Возвращает длину строки.                                         |
| 11 | boolean matches(String regex)      | Сообщает, соответствует ли эта строка заданному регулярному выражению.            |
| 12 | String replace(char oldChar, char newChar) | Возвращает новую строку, в результате, заменив все вхождения oldChar в этой строке на newChar. |
| 13 | String[] split(String regex)       | Разделение строки на массив строк. Регулярное выражение regex задает, где именно происходит разделение между строками.|
| 14 | boolean startsWith(String prefix)  | Проверяет, начинается ли эта строка с заданного префикса.                         |
| 15 | String substring(int beginIndex)   | Возвращает новую строку, которая является подстрокой данной строки.                |
| 16 | char[] toCharArray()               | Преобразует эту строку в новый массив символов.                                    |
| 17 | String toLowerCase()               | Преобразует все символы в данной строке в нижний регистр, используя правила данного языкового стандарта. |
| 18 | String toUpperCase()               | Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта. |
| 19 | String trim()                      | Возвращает копию строки с пропущенными начальными и конечными пробелами.           |
| 20 | static String valueOf(primitive data type x) | Возвращает строковое представление переданного типа данных аргумента.           |

## Задача: "Палиндромы"
Дана текстовая строка. Проверить является ли она палиндромом?
Палиндром - это такая строка, которая читается одинаково справа налево и слева направо.
![[Pasted image 20231209005914.png]]
### Код программы:
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите строку");
        // Ввод строки из консоли
        String str = scanner.nextLine();
        
        // Проверка на палиндром строкой str
        // Изначально считаем строку - палиндромом
        boolean isPalindrome = true;
        // Проверяем только до середины, дальше смысла нет
        for (int i = 0; i < str.length() / 2; i++) {
	        // Проверяем совпадение символов
            if (str.charAt(i) != str.charAt(len - i - 1)) { 
	            // Если символы в какой-то момент не совпали, то
	            // строка не палиндром
                isPalindrome = false;
                break;
            }
        }
        if (isPalindrome) {
            System.out.println("Это палиндром");
		}
        else {
            System.out.println("Это не палиндром");
		}

        scanner.close();
    }
}
```
Пример работы:
```
Введите строку
мадам
Это палиндром
```
Пример работы:
```
Введите строку
лопата
Это не палиндром 
```
## Пример: удаление всех вхождений подстроки в строку
```java
System.out.println("Введите строку");
String str = scanner.nextLine();

System.out.println("Введите удаляемую подстроку");
String str1 = scanner.nextLine();

str = str.replace(str1, "");
System.out.println("Полученная строка = " + str);
```
Консоль:
```
Введите строку
барабан
Введите удаляемую подстроку
ба
Полученная строка = ран
```
## Пример: разбиения строки на слова:
```java
String str = new String("Ижевск столица Удмуртской Республики");
System.out.println("Строка " + str + " состоит из слов:");
String[] words = str.split(" ");  // разделитель – один пробел
for(String word : words)          // вывод слов массива word
System.out.println(word);
```
Консоль:
```
Строка Ижевск столица Удмуртской Республики состоит из слов:
Ижевск
столица
Удмуртской
Республики
```

## Преобразование строки в число (или другой объект) и наоборот

• Для преобразования объекта класса или значения любого примитивного
типа данных в строковое представление можно использовать метод
`String.valueOf()`;

• Для перевода строкового представления в число можно использовать
методы соответствующих числовых классов-оболочек, которые
начинаются на parse, например `parseInt()`, `parseDouble()` и т. п.

### Примеры преобразований:
```java
// Преобразование примитивного типа в строку
String s1 = String.valueOf(111);      // Преобразование целого в строку
String s2 = String.valueOf(3.14D);    // Преобразование вещественного
String s3 = String.valueOf(123456L);  // Преобразование long
String s4 = String.valueOf(true);     // Преобразование логического
String s = s1 + " " + s2 + " " + s3 + " " + s4;
System.out.println(s);

// Преобразование строки в объект числового класса-оболочки
Integer i = Integer.parseInt("777");
Float f = Float.parseFloat("2.71F");
Double d = Double.parseDouble("1.23E-02");
System.out.println(i + " " + f + " " + d);
```
Консоль:
```
111 3.14 123456 true
777 2.71 0.0123
```
## Задача: "Осторожно, скобки закрываются!"
Дана строка символов. Проверить, соблюден ли баланс круглых скобок в строке.
### Код программы:
```java
public class Main {
	public static void main(String[] args) {
	    String s = "(a + (1 + 2) * (3 - 4))/(a - b)";
	
	    int count = 0; // счетчик открывающих скобок
	    for (int i = 0; i < s.length(); i++) {
	        if (s.charAt(i) == '(')
	            count++;
	        if (s.charAt(i) == ')')
	            count--;
	        if (count < 0)
	            break;
	    }
	    System.out.println("Баланс скобок в строке " + s
	        + (count == 0 ? " соблюден" : " нарушен"));
	}
}
```
Консоль:
```
Баланс скобок в строке (a + (1 + 2) * (3 - 4))/(a - b) соблюден
// другая строка:
Баланс скобок в строке (a + (1 + 2) * (3 - 4) /(a - b) нарушен
```
### Объяснение алгоритма
1. **Инициализация счетчика**: Вначале у нас есть счетчик, который отслеживает баланс скобок. Он начинается с нуля.

2. **Перебор символов строки**: Проходим по всей строке, рассматривая каждый ее символ. 

3. **Обработка открывающих скобок**: Когда мы находим открывающую скобку (например, `(`), мы увеличиваем счетчик на единицу. Это делается потому, что каждая открывающая скобка требует соответствующей закрывающей скобки для баланса.

4. **Обработка закрывающих скобок**: Когда мы находим закрывающую скобку (например, `)`), мы уменьшаем счетчик на единицу. Это символизирует, что одна открывающая скобка была "закрыта" или "сбалансирована".

5. **Проверка на досрочное нарушение баланса**: Важным моментом является проверка счетчика на отрицательное значение в процессе перебора. Если счетчик становится отрицательным (что означает, что мы нашли закрывающую скобку без соответствующей открывающей), это немедленно указывает на нарушение баланса.

6. **Окончательная проверка баланса**: После того, как вся строка проверена, мы смотрим на значение счетчика. Если счетчик равен нулю, это означает, что все открывающие скобки в строке имеют соответствующие закрывающие, и баланс соблюден. Если счетчик не равен нулю, это указывает на нарушение баланса скобок (либо слишком много открывающих, либо слишком много закрывающих скобок).

Таким образом, общая логика алгоритма заключается в отслеживании баланса открывающих и закрывающих скобок с помощью счетчика, который увеличивается и уменьшается соответственно. Для случая с разными типами скобок, например: `[]`, `{}`, - алгоритм будет сложнее.

## Следующая тема
Дополнительно: [[StringBuilder]], более эффективный способ конструирования строк